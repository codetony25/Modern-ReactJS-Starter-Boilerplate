'use strict';

var React = require('react');
var resolveType = require('./resolveType');

var _require = require('./fixupReactRouter');

var isReactRouterish = _require.isReactRouterish;
var extractRouteHandlerComponents = _require.extractRouteHandlerComponents;


if (React.createElement.isPatchedByReactHotLoader) {
  throw new Error('Cannot patch React twice.');
}

var createElement = React.createElement;
function patchedCreateElement(type, props) {
  // Trick React into rendering a proxy so that
  // its state is preserved when the class changes.
  // This will update the proxy if it's for a known type.
  var resolvedType = resolveType(type);

  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var element = createElement.apply(undefined, [resolvedType, props].concat(args));

  // This is lame but let's focus on shipping.
  // https://github.com/gaearon/react-hot-loader/issues/249
  if (isReactRouterish(type)) {
    // Ideally we want to teach React Router to receive children.
    // We're not in a perfect world, and a dirty workaround works for now.
    // https://github.com/reactjs/react-router/issues/2182
    var resolvedProps = element.props;
    var routeHandlers = extractRouteHandlerComponents(resolvedProps, resolveType);
    // Side effect ğŸ˜±
    // Force proxies to update since React Router ignores new props.
    routeHandlers.forEach(resolveType);
  }

  return element;
}
patchedCreateElement.isPatchedByReactHotLoader = true;
React.createElement = patchedCreateElement;